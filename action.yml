name: 'Infer Agent Action'
description: 'Run Infer CLI agent on GitHub issues with support for multiple AI providers, automatic pull request creation, and progress tracking'
author: 'Inference Gateway'

branding:
  icon: 'cpu'
  color: 'blue'

inputs:
  github-token:
    description: 'GitHub token for posting comments and accessing API'
    required: true

  trigger-phrase:
    description: 'Phrase to trigger the agent (e.g., @infer)'
    required: false
    default: '@infer'

  model:
    description: 'Model to use (e.g., anthropic/claude-sonnet-4, openai/gpt-4, google/gemini-pro)'
    required: true

  version:
    description: 'Infer CLI version to install (default: v0.68.3)'
    required: false
    default: 'v0.68.3'

  anthropic-api-key:
    description: 'Anthropic API key (required if using Anthropic models)'
    required: false

  openai-api-key:
    description: 'OpenAI API key (required if using OpenAI models)'
    required: false

  google-api-key:
    description: 'Google API key (required if using Google/Gemini models)'
    required: false

  deepseek-api-key:
    description: 'DeepSeek API key (required if using DeepSeek models)'
    required: false

  groq-api-key:
    description: 'Groq API key (required if using Groq models)'
    required: false

  mistral-api-key:
    description: 'Mistral API key (required if using Mistral models)'
    required: false

  cloudflare-api-key:
    description: 'Cloudflare API key (required if using Cloudflare models)'
    required: false

  cohere-api-key:
    description: 'Cohere API key (required if using Cohere models)'
    required: false

  ollama-api-key:
    description: 'Ollama API key (required if using Ollama)'
    required: false

  ollama-cloud-api-key:
    description: 'Ollama Cloud API key (required if using Ollama Cloud)'
    required: false

  max-turns:
    description: 'Maximum number of agent iterations (default: 50)'
    required: false
    default: '50'

  custom-instructions:
    description: 'Custom instructions to append to the default agent instructions (which include plan creation, progress tracking, file changes, and PR workflow)'
    required: false
    default: ''

  bash-whitelist-commands:
    description: 'Comma-separated list of bash commands to whitelist (e.g., "npm,yarn,pnpm"). These are added to the default whitelist.'
    required: false
    default: ''

  bash-whitelist-patterns:
    description: 'Comma-separated list of regex patterns to whitelist bash commands (e.g., "^npm .*,^yarn .*"). These are added to the default patterns.'
    required: false
    default: ''

  enable-git-operations:
    description: 'Enable git operations (checkout, add, commit, push). Default: true. Set to false if you want the agent to only post comments without creating PRs.'
    required: false
    default: 'true'

outputs:
  result:
    description: 'Result of the agent execution'
    value: ${{ steps.run-agent.outputs.result }}

  exit-code:
    description: 'Exit code from agent command'
    value: ${{ steps.run-agent.outputs.exit-code }}

runs:
  using: 'composite'
  steps:
    - name: Check trigger conditions
      id: check-trigger
      shell: bash
      run: |
        TRIGGERED=false
        TRIGGER_PHRASE="${{ inputs.trigger-phrase }}"
        MODEL_OVERRIDE=""

        extract_model_override() {
          local text="$1"
          if [[ "$text" =~ /model[[:space:]]+([a-zA-Z0-9/_.:-]+) ]]; then
            echo "${BASH_REMATCH[1]}"
          fi
        }

        if [[ "${{ github.event_name }}" == "issues" ]]; then
          ISSUE_TITLE=$(cat <<'ISSUE_TITLE_EOF'
        ${{ github.event.issue.title }}
        ISSUE_TITLE_EOF
        )
          ISSUE_BODY=$(cat <<'ISSUE_BODY_EOF'
        ${{ github.event.issue.body }}
        ISSUE_BODY_EOF
        )

          if [[ "$ISSUE_TITLE" == *"$TRIGGER_PHRASE"* ]] || [[ "$ISSUE_BODY" == *"$TRIGGER_PHRASE"* ]]; then
            TRIGGERED=true
            MODEL_OVERRIDE=$(extract_model_override "$ISSUE_BODY")
            if [[ -n "$MODEL_OVERRIDE" ]]; then
              echo "Detected model override from issue body: $MODEL_OVERRIDE"
            fi
          fi
        fi

        if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
          COMMENT_AUTHOR="${{ github.event.comment.user.login }}"

          if [[ "$COMMENT_AUTHOR" == *"[bot]" ]] || [[ "${{ github.event.comment.user.type }}" == "Bot" ]]; then
            echo "Comment is from bot user '$COMMENT_AUTHOR'. Skipping to prevent recursion."
            TRIGGERED=false
          else
            COMMENT_BODY=$(cat <<'COMMENT_BODY_EOF'
        ${{ github.event.comment.body }}
        COMMENT_BODY_EOF
        )
            COMMENT_ID="${{ github.event.comment.id }}"

            if [[ "$COMMENT_BODY" == *"$TRIGGER_PHRASE"* ]]; then
              TRIGGERED=true
              echo "comment_id=$COMMENT_ID" >> $GITHUB_OUTPUT
              MODEL_OVERRIDE=$(extract_model_override "$COMMENT_BODY")
              if [[ -n "$MODEL_OVERRIDE" ]]; then
                echo "Detected model override: $MODEL_OVERRIDE"
              fi
            fi
          fi
        fi

        echo "model_override=$MODEL_OVERRIDE" >> $GITHUB_OUTPUT
        echo "triggered=$TRIGGERED" >> $GITHUB_OUTPUT

        if [[ "$TRIGGERED" == "false" ]]; then
          echo "Trigger phrase '$TRIGGER_PHRASE' not found. Skipping action."
          exit 0
        fi

        echo "Trigger phrase '$TRIGGER_PHRASE' detected. Proceeding with agent execution."

    - name: Add eyes emoji reaction to comment
      if: steps.check-trigger.outputs.triggered == 'true' && github.event_name == 'issue_comment'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        COMMENT_ID="${{ steps.check-trigger.outputs.comment_id }}"
        REPO="${{ github.repository }}"

        curl -X POST \
          -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$REPO/issues/comments/$COMMENT_ID/reactions" \
          -d '{"content":"eyes"}'

        echo "Added eyes emoji reaction to comment #$COMMENT_ID"

    - name: Post initial cooking message
      id: cooking-message
      if: steps.check-trigger.outputs.triggered == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        ISSUE_NUMBER="${{ github.event.issue.number }}"
        REPO="${{ github.repository }}"

        echo "Cleaning up old cooking messages..."
        curl -s \
          -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$REPO/issues/$ISSUE_NUMBER/comments" \
          | jq -r '.[] | select(.body | contains("I'\''m cooking")) | .id' \
          | while read comment_id; do
              echo "Deleting old cooking message #$comment_id"
              curl -s -X DELETE \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/$REPO/issues/comments/$comment_id"
            done

        COOKING_MESSAGE="<img src=\"https://raw.githubusercontent.com/inference-gateway/infer-action/main/assets/cooking.gif\" width=\"100\" height=\"100\" alt=\"Cooking\" />

        I'm cooking...will get back to you soon..."

        COMMENT_BODY=$(jq -n \
          --arg body "$COOKING_MESSAGE" \
          '{body: $body}')

        COMMENT_RESPONSE=$(curl -s -X POST \
          -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$REPO/issues/$ISSUE_NUMBER/comments" \
          -d "$COMMENT_BODY")

        COOKING_COMMENT_ID=$(echo "$COMMENT_RESPONSE" | jq -r '.id')
        echo "cooking_comment_id=$COOKING_COMMENT_ID" >> $GITHUB_OUTPUT
        echo "Posted cooking message to issue #$ISSUE_NUMBER (comment #$COOKING_COMMENT_ID)"

    - name: Install Infer CLI
      id: install-cli
      if: steps.check-trigger.outputs.triggered == 'true'
      shell: bash
      run: |
        VERSION="${{ inputs.version }}"
        curl -fsSL https://raw.githubusercontent.com/inference-gateway/cli/main/install.sh | bash -s -- ${VERSION:+--version $VERSION}
        infer version

    - name: Initialize Infer CLI
      id: init-cli
      if: steps.check-trigger.outputs.triggered == 'true'
      shell: bash
      run: |
        infer init --overwrite

    - name: Configure Git
      id: configure-git
      if: steps.check-trigger.outputs.triggered == 'true'
      shell: bash
      run: |
        # TODO - use github app ID
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        echo "Git configured for commits"

    - name: Run Infer agent
      id: run-agent
      if: steps.check-trigger.outputs.triggered == 'true'
      shell: bash
      env:
        INFER_AGENT_MODEL: ${{ steps.check-trigger.outputs.model_override || inputs.model }}
        ANTHROPIC_API_KEY: ${{ inputs.anthropic-api-key }}
        OPENAI_API_KEY: ${{ inputs.openai-api-key }}
        GOOGLE_API_KEY: ${{ inputs.google-api-key }}
        DEEPSEEK_API_KEY: ${{ inputs.deepseek-api-key }}
        GROQ_API_KEY: ${{ inputs.groq-api-key }}
        MISTRAL_API_KEY: ${{ inputs.mistral-api-key }}
        CLOUDFLARE_API_KEY: ${{ inputs.cloudflare-api-key }}
        OLLAMA_API_KEY: ${{ inputs.ollama-api-key }}
        OLLAMA_CLOUD_API_KEY: ${{ inputs.ollama-cloud-api-key }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        if [[ "${{ inputs.enable-git-operations }}" == "true" ]]; then
          export INFER_TOOLS_BASH_WHITELIST_COMMANDS="gh,git,${{ inputs.bash-whitelist-commands }}"
          export INFER_TOOLS_BASH_WHITELIST_PATTERNS="^gh .*,^git .*,${{ inputs.bash-whitelist-patterns }}"
        else
          export INFER_TOOLS_BASH_WHITELIST_COMMANDS="${{ inputs.bash-whitelist-commands }}"
          export INFER_TOOLS_BASH_WHITELIST_PATTERNS="${{ inputs.bash-whitelist-patterns }}"
        fi

        ISSUE_TITLE=$(cat <<'ISSUE_TITLE_EOF'
        ${{ github.event.issue.title }}
        ISSUE_TITLE_EOF
        )
        ISSUE_BODY=$(cat <<'ISSUE_BODY_EOF'
        ${{ github.event.issue.body }}
        ISSUE_BODY_EOF
        )
        ISSUE_NUMBER="${{ github.event.issue.number }}"
        REPO="${{ github.repository }}"
        COOKING_COMMENT_ID="${{ steps.cooking-message.outputs.cooking_comment_id }}"

        # Build the system prompt with GitHub integration instructions
        SYSTEM_PROMPT=$(cat <<-SYSEOF
        # GitHub Issue Agent Instructions

        You are working on a GitHub issue in an automated CI environment. Follow these instructions:

        ## Plan and Progress Tracking

        **CRITICAL**: When using the Github tool, the \`repo\` parameter must ALWAYS be the full repository name in "owner/repo" format (e.g., "${REPO}"). Never use just the organization or owner name alone.

        **CRITICAL**: A cooking message has already been posted as comment #${COOKING_COMMENT_ID}. You MUST update this existing comment instead of creating a new one.

        1. **At the very beginning**, create a plan with todos for solving this issue.

        2. **Update the cooking comment** with your plan using the Github tool:
           \`\`\`
           Github(resource="update_comment", repo="${REPO}", comment_id=${COOKING_COMMENT_ID}, comment_body="your comment")
           \`\`\`
           **IMPORTANT**:
           - The \`repo\` parameter MUST be the full repository name in the format "owner/repo" (e.g., "${REPO}"). Do NOT use just the organization name.
           - Use comment_id=${COOKING_COMMENT_ID} to update the existing cooking message
           - DO NOT create a new comment with create_comment

           Format your comment with:
           - A header like "## Agent Plan"
           - Your todos in markdown checkbox format: \`- [ ] Task description\`
           - Brief description of your approach

        3. **Continue using comment ID ${COOKING_COMMENT_ID}** for all updates throughout the workflow.

        4. **Update the comment frequently** as you make progress using the Github tool:
           \`\`\`
           Github(resource="update_comment", repo="${REPO}", comment_id=${COOKING_COMMENT_ID}, comment_body="updated content")
           \`\`\`
           - Mark completed todos with \`[x]\` instead of \`[ ]\`
           - Add status updates about what you're currently working on
           - Include any relevant progress information

        5. **Real-time updates**: Update the comment (ID: ${COOKING_COMMENT_ID}) after each significant step or todo completion.

        6. **Final update**: When all tasks are complete, update the comment (ID: ${COOKING_COMMENT_ID}) one final time with:
           - All todos marked as complete
           - A summary of what was accomplished
           - Any relevant notes or follow-up actions

        ## Making Changes and Creating Pull Requests

        When you need to make file changes to resolve the issue:

        **Important: Follow Conventional Commit Format**
        - Use conventional commit format for both commit messages and PR titles
        - Format: `type(scope): Description`
        - Common types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
        - Scope should describe the area of change (e.g., `api`, `ui`, `auth`, `config`)
        - Examples: 
          - `fix(api): Resolve authentication timeout`
          - `feat(ui): Add dark mode toggle`
          - `docs(readme): Update installation instructions`

        **CRITICAL: Branch Checking Logic**
        - **Always check your current branch first** using `git branch --show-current`
        - **If already on a feature branch** (not `main` or `master`):
          - Make changes directly on the current branch
          - Commit and push to the current branch
          - DO NOT create a new branch or pull request
        - **If on main branch**:
          - Create a new branch for your changes
          - Create a pull request targeting main

        **Step 1: Check Current Branch**
        \`\`\`bash
        CURRENT_BRANCH=$(git branch --show-current)
        echo "Current branch: $CURRENT_BRANCH"
        \`\`\`

        **Step 2: Branch Strategy**
        - **If on main branch**:
          \`\`\`bash
          git checkout -b fix/issue-${ISSUE_NUMBER}
          \`\`\`
        - **If already on a feature branch** (branch name contains `/` or is not `main`/`master`):
          \`\`\`bash
          # Stay on current branch, no need to create new branch
          echo "Already on feature branch: $CURRENT_BRANCH"
          \`\`\`

        3. **Make your file changes** using appropriate tools (Edit, Write, etc.)

        4. **Commit your changes** with descriptive commit messages:
           \`\`\`bash
           git add .
           git commit -m "fix(scope): Description of changes"
           \`\`\`

        5. **Push the branch** to the remote repository:
           \`\`\`bash
           git push -u origin HEAD
           \`\`\`

        6. **Create a pull request ONLY if on main branch**:
           - **If on main branch** (created new branch):
             \`\`\`
             Github(resource="create_pull_request", repo="${REPO}", title="fix(scope): Brief description", body="Resolves #${ISSUE_NUMBER}", head="fix/issue-${ISSUE_NUMBER}", base="main")
             \`\`\`
           - **If on feature branch**:
             - DO NOT create a pull request
             - Simply continue working on the existing branch

           **IMPORTANT**: The \`repo\` parameter MUST be the full repository name "${REPO}" (in "owner/repo" format), NOT just the organization name.

        7. **Include appropriate links in your final artifact**:
           - If created a PR: Include the pull request link
           - If working on existing branch: Include the branch name and mention that changes were pushed to the existing branch

        **Important**: The final output should include both:
        - A summary of what was accomplished
        - Either a PR link (if new PR created) or branch name (if working on existing branch)

        ## Environment

        - The \`gh\` CLI is authenticated with GITHUB_TOKEN
        - Repository: ${REPO}
        - Issue Number: ${ISSUE_NUMBER}
        - You have full access to repository files and can make changes

        SYSEOF
        )

        if [[ -n "${{ inputs.custom-instructions }}" ]]; then
          SYSTEM_PROMPT=$(cat <<-ENDPROMPT
        $SYSTEM_PROMPT

        ## Additional Instructions

        ${{ inputs.custom-instructions }}
        ENDPROMPT
        )
        fi

        export INFER_AGENT_SYSTEM_PROMPT="$SYSTEM_PROMPT"

        TASK=$(cat <<-END
        Resolve the following GitHub issue:

        Issue #$ISSUE_NUMBER: $ISSUE_TITLE

        $ISSUE_BODY
        END
        )

        echo "=========================================="
        echo "SYSTEM PROMPT:"
        echo "=========================================="
        echo "$SYSTEM_PROMPT"
        echo "=========================================="
        echo ""
        echo "Running agent with task:"
        echo "$TASK"
        echo "---"

        infer agent -m "$INFER_AGENT_MODEL" "$TASK" 2>&1 | tee /tmp/agent-output.txt || EXIT_CODE=$?
        EXIT_CODE=${EXIT_CODE:-0}

        # Extract failed tool calls from the output using jq only
        echo ""
        echo "=========================================="
        echo "FAILED TOOL CALLS:"
        echo "=========================================="
        # Use jq to extract and format failed tool calls from the agent output
        cat /tmp/agent-output.txt | jq -R 'select(test("{\"success\": false")) | fromjson? | select(.success == false)' 2>/dev/null | jq -r '. | "Tool: \(.tool_name // .name // "unknown"), Error: \(.error // .message // "unknown error")"' 2>/dev/null | tee /tmp/failed-tool-calls.txt || echo "No failed tool calls detected"
        echo "=========================================="

        echo "exit-code=$EXIT_CODE" >> $GITHUB_OUTPUT

        if [[ $EXIT_CODE -eq 0 ]]; then
          echo "result=✅ Agent completed successfully" >> $GITHUB_OUTPUT
          echo "✅ Agent completed successfully"
        else
          echo "result=❌ Agent failed with exit code $EXIT_CODE" >> $GITHUB_OUTPUT
          echo "❌ Agent failed with exit code $EXIT_CODE"
          exit $EXIT_CODE
        fi

    - name: Post results as comment
      if: steps.check-trigger.outputs.triggered == 'true' && always()
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        ISSUE_NUMBER="${{ github.event.issue.number }}"
        REPO="${{ github.repository }}"
        EXIT_CODE="${{ steps.run-agent.outputs.exit-code }}"

        MODEL_USED="${{ steps.check-trigger.outputs.model_override }}"
        if [[ -z "$MODEL_USED" ]]; then
          MODEL_USED="${{ inputs.model }}"
        fi

        if [[ -f /tmp/agent-output.txt ]]; then
          AGENT_OUTPUT=$(cat /tmp/agent-output.txt)
        else
          AGENT_OUTPUT="No output available"
        fi

        if [[ -f /tmp/failed-tool-calls.txt ]]; then
          FAILED_TOOL_CALLS=$(cat /tmp/failed-tool-calls.txt)
        else
          FAILED_TOOL_CALLS="No failed tool calls detected"
        fi

        if [[ "$EXIT_CODE" == "0" ]]; then
          STATUS_ICON="✅"
          STATUS_TEXT="Success"
        else
          STATUS_ICON="❌"
          STATUS_TEXT="Failed"
        fi

        COMMENT_BODY=$(cat <<-END
        ## $STATUS_ICON Infer Agent Result: $STATUS_TEXT

        **Model:** \`$MODEL_USED\`
        **Exit Code:** \`$EXIT_CODE\`
        **Workflow:** [View Job](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

        <details>
        <summary>Agent Output</summary>

        \`\`\`
        $AGENT_OUTPUT
        \`\`\`

        </details>

        <details>
        <summary>Failed Tool Calls</summary>

        \`\`\`
        $FAILED_TOOL_CALLS
        \`\`\`

        </details>

        ---
        *Triggered by ${{ github.actor }} | Model: \`$MODEL_USED\` | [Infer Action](https://github.com/inference-gateway/infer-action)*
        END
        )

        curl -X POST \
          -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$REPO/issues/$ISSUE_NUMBER/comments" \
          -d "$(jq -n --arg body "$COMMENT_BODY" '{body: $body}')"

        echo "Comment posted to issue #$ISSUE_NUMBER"

    - name: Cleanup
      if: steps.check-trigger.outputs.triggered == 'true' && always()
      shell: bash
      run: |
        rm -f /tmp/agent-output.txt /tmp/failed-tool-calls.txt

        echo "Cleanup completed"
